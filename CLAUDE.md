# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

CUHABot is a Korean Discord bot with dungeon exploration features. The bot uses Discord.py for Discord API interactions and Tortoise ORM for PostgreSQL database operations.

## Development Commands

### Running the Bot
```bash
python bot.py
```

### Environment Setup
1. Create a `.env` file with the following variables:
   - `DEV` - Set to "TRUE" for development mode
   - `DISCORD_TOKEN` / `DEV_DISCORD_TOKEN` - Discord bot token
   - `APPLICATION_ID` / `DEV_APPLICATION_ID` - Discord application ID
   - `GUILD_ID` - Discord guild (server) ID
   - `DATABASE_URL` - MySQL database host
   - `DATABASE_USER` - MySQL username
   - `DATABASE_PASSWORD` - MySQL password
   - `DATABASE_PORT` - MySQL port
   - `DATABASE_TABLE` - MySQL database name

2. Install dependencies:
```bash
pip install -r requirements.txt
```

### Model Generation
When adding new models, regenerate `models/__init__.py`:
```bash
python models/util/generate_model.py
```

## Architecture

### Core Components

**bot.py** - Main entry point. Initializes the Discord bot, loads cogs, syncs commands to guild, and initializes database connection and static data cache on ready.

**config.py** - Game configuration constants. All magic numbers and balance-related constants are managed here (combat, damage, attributes, status effects, dungeon, drops, UI, etc.).

**exceptions.py** - Custom exception class hierarchy. All exceptions inherit from `CUHABotError` for consistent error handling.

**cogs/** - Discord command groups (follows discord.py Cog pattern):
- `dungeon_command.py` - Dungeon exploration and all in-game commands
- `server_admin_command.py` - Server administration commands
- `server_manage_command.py` - Server management commands

**models/** - Tortoise ORM database models:
- All models are auto-imported via `models/__init__.py` (generated by `models/util/generate_model.py`)
- User models: `users.py`, `user_stats.py`, `user_skill_deck.py`, `user_owned_skill.py`, `user_equipment.py`, `user_inventory.py`, `user_deck_preset.py`, `user_collection.py`
- Item models: `item.py` (base), `base_item.py` (abstract), `equipment_item.py`, `consume_item.py`, `grade.py`, `item_grade_probability.py`, `equip_pos.py`
- Content models: `dungeon.py`, `dungeon_spawn.py`, `dungeon_user_pos.py`, `monster.py`, `skill.py`, `droptable.py`
- `models/repos/` - Repository pattern for data access with caching
- `models/repos/static_cache.py` - In-memory cache for static data (dungeons, monsters, items, skills) loaded at bot startup
- `models/util/item_embed.py` - Item embed generation utilities

**service/** - Business logic layer:
- `session.py` - Manages active dungeon sessions (one session per user)
- `dungeon_service.py` - High-level dungeon exploration orchestration
- `user_service.py` - User profile and stats management
- `inventory_service.py` - Inventory management
- `equipment_service.py` - Equipment and stat application
- `shop_service.py` - Shop/market logic (buy/sell items and skills)
- `skill_deck_service.py` - Skill deck management
- `skill_ownership_service.py` - Skill acquisition and ownership
- `collection_service.py` - Item/skill collection tracker
- `item_use_service.py` - Consumable item usage
- `reward_service.py` - Combat reward distribution
- `healing_service.py` - HP healing/regeneration
- `service/dungeon/` - Dungeon combat subsystem:
  - `dungeon_service.py` - Core dungeon combat loop and event handling
  - `encounter_service.py` - Encounter generation
  - `encounter_types.py` - Encounter type definitions
  - `skill_component.py` - Component-based skill system using tag-based registration
  - `skill.py` - Skill runtime representation
  - `buff.py` - Buff/debuff system
  - `item_service.py` - Item drop service
  - `turn_config.py` - Turn-based combat configuration
- `service/combat/` - Combat calculations:
  - `damage_calculator.py` - Damage calculation engine

**DTO/** - Discord UI Views (discord.py View components):
- `dungeon_select_view.py` - Dungeon selection dropdown
- `dungeon_control.py` - In-dungeon control buttons
- `encounter_view.py` - Combat encounter UI
- `fight_or_flee.py` - Combat choice view
- `inventory_view.py` - Inventory management UI
- `shop_view.py` - Shop/market UI
- `skill_deck_view.py` - Skill deck/loadout UI
- `stat_distribution_view.py` - Stat allocation UI
- `user_info_view.py` - User profile UI
- `collection_view.py` - Collection/database UI

**decorator/** - Custom decorators:
- `account.py` - `@requires_account()` decorator to enforce user registration before command use (auto-registers if not found)

**resources/** - Static resources:
- `item_emoji.py` - Discord emoji manager for items

**scripts/** - Database migration and seeding scripts:
- `seed_data.py` - Initial game data seeding
- `seed_skills.py` - Skill data seeding
- Various migration scripts for schema changes

**utility/** - Utility scripts:
- `clear_command.py` - Clear Discord commands
- `command_list.py` - List all commands

### Data Flow

1. **Command Invocation**: User invokes slash command â†’ Discord.py routes to appropriate Cog
2. **Authorization**: `@requires_account()` decorator checks if user exists in database (auto-registers if not)
3. **Business Logic**: Cog delegates to service layer (`service/`)
4. **Data Access**: Service layer accesses data via repository pattern (`models/repos/`)
5. **Response**: Service returns result â†’ Cog sends Discord embed/view to user

### Session Management

The bot maintains in-memory `DungeonSession` objects in `service/session.py`:
- Each user can have one active session at a time
- Sessions track dungeon state, combat status, user stats, and Discord message references
- Sessions are cleaned up when dungeon exploration ends or user leaves

### Skill System

Skills use a component-based architecture:
- `Skill_Model` (database) stores skill configuration as JSON
- At startup, skills are loaded and components are instantiated based on JSON config
- Components are registered via `@register_skill_with_tag()` decorator
- Components implement turn-based callbacks (`on_turn`, `on_turn_start`, etc.)
- Available component types: `attack`, `heal`, `buff`

### Static Data Caching

On bot startup (`bot.py:on_ready()`), `load_static_data()` loads:
- All dungeons, monsters, items, and skills into memory caches
- Dungeon spawn tables linking dungeons to monsters
- This prevents database queries during time-sensitive gameplay

## Important Patterns

### Command Registration
All commands are guild-scoped (not global) using `@app_commands.guilds(GUILD_ID)` for instant updates during development.

### Discord Interaction Pattern
Most dungeon interactions use a dual-message pattern:
- Public message in channel showing dungeon progress
- Private DM to user with control buttons (start, stop, flee)

### Database ORM
- Uses Tortoise ORM with async/await (PostgreSQL)
- All database operations are async
- Models auto-generate schemas via `Tortoise.generate_schemas()`

### Error Handling
The bot includes a global error handler for `CommandSignatureMismatch` that auto-resyncs commands when Discord's cached command signature becomes stale.

## Code Style Notes

- Most user-facing text is in Korean (ëª…ë ¹ì–´, ë˜ì „, etc.)
- Uses Korean variable names in some places (`ë˜ì „`, `ë°±ì¤€`, etc.)
- Logging configured at INFO level with timestamp format

---

# ğŸ› ï¸ Development Guidelines (ê°œë°œ ì§€ì¹¨)

## í•„ìˆ˜ ì°¸ê³  ë¬¸ì„œ

**ê°œë°œ ì „ ë°˜ë“œì‹œ í™•ì¸:**
- `docs/TODO.md` - ìš°ì„ ìˆœìœ„ë³„ ê¸°ëŠ¥ ëª©ë¡ ë° ì§„í–‰ ìƒí™©
- `docs/GameOverview.md` - ê²Œì„ ì‹œìŠ¤í…œ ì „ì²´ ê¸°íš
- `docs/Items.md` - ì•„ì´í…œ/ì¥ë¹„ ê¸°íš
- `docs/Skills.md` - ìŠ¤í‚¬ ì‹œìŠ¤í…œ ê¸°íš
- `docs/Dungeons.md` - ë˜ì „ ê¸°íš
- `docs/Monsters.md` - ëª¬ìŠ¤í„° ê¸°íš
- `docs/Balance.md` - ë°¸ëŸ°ìŠ¤ ìˆ˜ì¹˜
- `docs/Database.md` - DB ìŠ¤í‚¤ë§ˆ

---

## Git Workflow

### ë¸Œëœì¹˜ ì „ëµ
```
master (main)
  â””â”€â”€ feature/{ê¸°ëŠ¥ëª…}     # ìƒˆ ê¸°ëŠ¥ ê°œë°œ
  â””â”€â”€ fix/{ë²„ê·¸ëª…}         # ë²„ê·¸ ìˆ˜ì •
  â””â”€â”€ refactor/{ëŒ€ìƒ}      # ë¦¬íŒ©í† ë§
  â””â”€â”€ test/{í…ŒìŠ¤íŠ¸ëŒ€ìƒ}    # í…ŒìŠ¤íŠ¸ ì¶”ê°€
```

### ë¸Œëœì¹˜ ë„¤ì´ë° ê·œì¹™
```bash
# ê¸°ëŠ¥ ê°œë°œ
git checkout -b feature/combat-system
git checkout -b feature/inventory-ui
git checkout -b feature/skill-deck

# ë²„ê·¸ ìˆ˜ì •
git checkout -b fix/session-memory-leak
git checkout -b fix/damage-calculation

# ë¦¬íŒ©í† ë§
git checkout -b refactor/dungeon-service
```

### ì»¤ë°‹ ì»¨ë²¤ì…˜
```
feat: ìƒˆë¡œìš´ ê¸°ëŠ¥ ì¶”ê°€
fix: ë²„ê·¸ ìˆ˜ì •
refactor: ì½”ë“œ ë¦¬íŒ©í† ë§ (ê¸°ëŠ¥ ë³€ê²½ ì—†ìŒ)
test: í…ŒìŠ¤íŠ¸ ì¶”ê°€/ìˆ˜ì •
docs: ë¬¸ì„œ ìˆ˜ì •
style: ì½”ë“œ í¬ë§·íŒ…, ì„¸ë¯¸ì½œë¡  ëˆ„ë½ ë“±
chore: ë¹Œë“œ ì—…ë¬´, íŒ¨í‚¤ì§€ ë§¤ë‹ˆì € ì„¤ì • ë“±

ì˜ˆì‹œ:
feat: í„´ì œ ì „íˆ¬ ë£¨í”„ êµ¬í˜„
fix: ë°ë¯¸ì§€ ê³„ì‚° ì‹œ ë°©ì–´ë ¥ ë¬´ì‹œ ë²„ê·¸ ìˆ˜ì •
test: DamageCalculator ìœ ë‹› í…ŒìŠ¤íŠ¸ ì¶”ê°€
```

### PR ê·œì¹™
1. `feature/*` â†’ `master` PR ìƒì„±
2. ëª¨ë“  í…ŒìŠ¤íŠ¸ í†µê³¼ í•„ìˆ˜
3. TODO.md ì—…ë°ì´íŠ¸ í™•ì¸
4. ìµœì†Œ 1ëª… ë¦¬ë·° (ê°€ëŠ¥í•œ ê²½ìš°)

---

## ì½”ë“œ ì›ì¹™

### 1. SRP (Single Responsibility Principle) ì¤€ìˆ˜

**Bad âŒ**
```python
class DungeonService:
    def explore(self): ...
    def fight(self): ...
    def calculate_damage(self): ...
    def apply_buff(self): ...
    def drop_item(self): ...
    def save_to_db(self): ...
```

**Good âœ…**
```python
class DungeonExploreService:
    """ë˜ì „ íƒí—˜ë§Œ ë‹´ë‹¹"""
    def explore(self): ...
    def handle_encounter(self): ...

class CombatService:
    """ì „íˆ¬ë§Œ ë‹´ë‹¹"""
    def start_combat(self): ...
    def process_turn(self): ...

class DamageCalculator:
    """ë°ë¯¸ì§€ ê³„ì‚°ë§Œ ë‹´ë‹¹"""
    def calculate_physical(self): ...
    def calculate_magical(self): ...

class BuffManager:
    """ë²„í”„/ë””ë²„í”„ë§Œ ë‹´ë‹¹"""
    def apply_buff(self): ...
    def remove_buff(self): ...
```

### 2. if ì¤‘ì²© ìµœì†Œí™” (Early Return íŒ¨í„´)

**Bad âŒ**
```python
def process_attack(self, attacker, target):
    if attacker is not None:
        if target is not None:
            if attacker.can_attack():
                if not target.is_dead():
                    damage = self.calculate_damage(attacker, target)
                    if damage > 0:
                        target.take_damage(damage)
                        return True
    return False
```

**Good âœ…**
```python
def process_attack(self, attacker, target) -> bool:
    if attacker is None:
        return False
    if target is None:
        return False
    if not attacker.can_attack():
        return False
    if target.is_dead():
        return False

    damage = self.calculate_damage(attacker, target)
    if damage <= 0:
        return False

    target.take_damage(damage)
    return True
```

### 3. Guard Clause íŒ¨í„´

```python
async def use_skill(self, user_id: int, skill_id: int) -> SkillResult:
    # Guard clauses
    user = await self.get_user(user_id)
    if not user:
        raise UserNotFoundError(user_id)

    skill = self.skill_cache.get(skill_id)
    if not skill:
        raise SkillNotFoundError(skill_id)

    if not user.can_use_skill(skill):
        raise InsufficientResourceError("MP ë¶€ì¡±")

    # Main logic (ì¤‘ì²© ì—†ì´ flatí•˜ê²Œ)
    result = skill.execute(user)
    await self.save_result(result)
    return result
```

### 4. í•¨ìˆ˜/ë©”ì„œë“œ í¬ê¸° ì œí•œ

- **ìµœëŒ€ 30ì¤„** ê¶Œì¥
- 30ì¤„ ì´ˆê³¼ ì‹œ ë¶„ë¦¬ ê³ ë ¤
- í•˜ë‚˜ì˜ í•¨ìˆ˜ëŠ” í•˜ë‚˜ì˜ ì‘ì—…ë§Œ

---

## í…ŒìŠ¤íŠ¸ ê·œì¹™

### í…ŒìŠ¤íŠ¸ êµ¬ì¡°
```
tests/
â”œâ”€â”€ unit/                    # ìœ ë‹› í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_damage_calculator.py
â”‚   â”œâ”€â”€ test_buff_manager.py
â”‚   â”œâ”€â”€ test_skill_component.py
â”‚   â””â”€â”€ ...
â”œâ”€â”€ integration/             # í†µí•© í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_combat_flow.py
â”‚   â”œâ”€â”€ test_dungeon_explore.py
â”‚   â””â”€â”€ ...
â”œâ”€â”€ e2e/                     # E2E í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_full_dungeon_run.py
â”‚   â”œâ”€â”€ test_user_journey.py
â”‚   â””â”€â”€ ...
â”œâ”€â”€ fixtures/                # í…ŒìŠ¤íŠ¸ ë°ì´í„°
â”‚   â”œâ”€â”€ monsters.py
â”‚   â”œâ”€â”€ skills.py
â”‚   â””â”€â”€ users.py
â””â”€â”€ conftest.py              # pytest ì„¤ì •
```

### ìœ ë‹› í…ŒìŠ¤íŠ¸ - ì„¸ë°€í•˜ê³  ì •ë°€í•˜ê²Œ

**ëª¨ë“  ê²½ê³„ ì¡°ê±´ í…ŒìŠ¤íŠ¸:**
```python
class TestDamageCalculator:
    """ë°ë¯¸ì§€ ê³„ì‚°ê¸° ìœ ë‹› í…ŒìŠ¤íŠ¸"""

    # ê¸°ë³¸ ì¼€ì´ìŠ¤
    def test_physical_damage_basic(self):
        """ê¸°ë³¸ ë¬¼ë¦¬ ë°ë¯¸ì§€ ê³„ì‚°"""
        calc = DamageCalculator()
        damage = calc.calculate_physical(attack=100, defense=50)
        assert damage == 75  # 100 - 50 * 0.5

    # ê²½ê³„ê°’ í…ŒìŠ¤íŠ¸
    def test_physical_damage_zero_attack(self):
        """ê³µê²©ë ¥ 0ì¼ ë•Œ"""
        damage = calc.calculate_physical(attack=0, defense=50)
        assert damage == 0

    def test_physical_damage_zero_defense(self):
        """ë°©ì–´ë ¥ 0ì¼ ë•Œ"""
        damage = calc.calculate_physical(attack=100, defense=0)
        assert damage == 100

    def test_physical_damage_high_defense(self):
        """ë°©ì–´ë ¥ì´ ë§¤ìš° ë†’ì„ ë•Œ (ìµœì†Œ ë°ë¯¸ì§€ ë³´ì¥)"""
        damage = calc.calculate_physical(attack=100, defense=500)
        assert damage >= 1  # ìµœì†Œ 1 ë°ë¯¸ì§€

    # íŠ¹ìˆ˜ ì¼€ì´ìŠ¤
    def test_physical_damage_with_armor_penetration(self):
        """ë°©ì–´ë ¥ ê´€í†µ ì ìš©"""
        damage = calc.calculate_physical(
            attack=100, defense=100, armor_pen=0.5
        )
        # ë°©ì–´ë ¥ 50% ë¬´ì‹œ: 100 - (100 * 0.5) * 0.5 = 75
        assert damage == 75

    def test_physical_damage_max_armor_penetration(self):
        """ìµœëŒ€ ë°©ì–´ë ¥ ê´€í†µ (70% ì œí•œ)"""
        damage = calc.calculate_physical(
            attack=100, defense=100, armor_pen=1.0  # 100% ìš”ì²­
        )
        # ìµœëŒ€ 70%ë§Œ ì ìš©
        assert calc.applied_armor_pen == 0.7

    # ì¹˜ëª…íƒ€ í…ŒìŠ¤íŠ¸
    def test_critical_hit_multiplier(self):
        """ì¹˜ëª…íƒ€ ë°°ìœ¨ ì ìš©"""
        damage = calc.calculate_physical(
            attack=100, defense=0, is_critical=True
        )
        assert damage == 150  # 1.5ë°°

    # ëœë¤ ë³€ë™ í…ŒìŠ¤íŠ¸
    def test_damage_variance(self):
        """ë°ë¯¸ì§€ Â±10% ëœë¤ ë³€ë™"""
        damages = [
            calc.calculate_physical(attack=100, defense=0)
            for _ in range(100)
        ]
        assert min(damages) >= 90   # -10%
        assert max(damages) <= 110  # +10%
```

**ë³µì¡í•œ ë¡œì§ í…ŒìŠ¤íŠ¸:**
```python
class TestAttributeSystem:
    """ì†ì„± ìƒì„± ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸"""

    @pytest.mark.parametrize("attacker_attr,defender_attr,expected_mult", [
        (Attribute.FIRE, Attribute.ICE, 1.5),      # ê°•ì 
        (Attribute.ICE, Attribute.FIRE, 0.5),      # ì•½ì 
        (Attribute.FIRE, Attribute.FIRE, 0.5),    # ë™ì¼
        (Attribute.HOLY, Attribute.DARK, 1.5),    # ê°•ì 
        (Attribute.DARK, Attribute.HOLY, 1.5),    # ìƒí˜¸ ê°•ì 
        (Attribute.NONE, Attribute.FIRE, 1.0),    # ë¬´ì†ì„±
    ])
    def test_attribute_multiplier(self, attacker_attr, defender_attr, expected_mult):
        system = AttributeSystem()
        mult = system.get_multiplier(attacker_attr, defender_attr)
        assert mult == expected_mult


class TestStatusEffect:
    """ìƒíƒœì´ìƒ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸"""

    def test_burn_dot_damage(self):
        """í™”ìƒ DOT ë°ë¯¸ì§€ (ìµœëŒ€ HPì˜ 3%)"""
        target = create_test_entity(max_hp=1000, current_hp=1000)
        burn = BurnEffect(stacks=1, duration=3)

        burn.apply_tick(target)

        assert target.current_hp == 970  # 1000 - 30

    def test_burn_stacking(self):
        """í™”ìƒ ìŠ¤íƒ (ìµœëŒ€ 5ìŠ¤íƒ)"""
        target = create_test_entity(max_hp=1000)

        for i in range(7):  # 7ë²ˆ ì ìš© ì‹œë„
            BurnEffect.apply_to(target)

        assert target.get_effect_stacks(EffectType.BURN) == 5  # ìµœëŒ€ 5

    def test_freeze_prevents_action(self):
        """ë™ê²° ì‹œ í–‰ë™ ë¶ˆê°€"""
        target = create_test_entity()
        freeze = FreezeEffect(duration=1)
        freeze.apply_to(target)

        assert target.can_act() == False

    def test_freeze_increases_damage_taken(self):
        """ë™ê²° ì‹œ ë°›ëŠ” í”¼í•´ +20%"""
        target = create_test_entity()
        FreezeEffect.apply_to(target)

        damage_mult = target.get_damage_taken_multiplier()
        assert damage_mult == 1.2
```

### í†µí•© í…ŒìŠ¤íŠ¸

```python
class TestCombatFlow:
    """ì „íˆ¬ íë¦„ í†µí•© í…ŒìŠ¤íŠ¸"""

    @pytest.fixture
    def combat_session(self):
        user = create_test_user(level=10, attack=100)
        monster = create_test_monster(hp=500, attack=50)
        return CombatSession(user, monster)

    async def test_full_combat_victory(self, combat_session):
        """ì „íˆ¬ ìŠ¹ë¦¬ ì „ì²´ íë¦„"""
        session = combat_session

        # ì „íˆ¬ ì‹œì‘
        await session.start()
        assert session.state == CombatState.IN_PROGRESS

        # í„´ ì§„í–‰ (ëª¬ìŠ¤í„° ì²˜ì¹˜ê¹Œì§€)
        while session.state == CombatState.IN_PROGRESS:
            result = await session.process_turn()
            assert result.turn_number <= 100  # ë¬´í•œë£¨í”„ ë°©ì§€

        # ìŠ¹ë¦¬ í™•ì¸
        assert session.state == CombatState.VICTORY
        assert session.monster.is_dead()

        # ë³´ìƒ í™•ì¸
        rewards = session.get_rewards()
        assert rewards.exp > 0
        assert rewards.gold > 0

    async def test_combat_with_skill_deck(self, combat_session):
        """ìŠ¤í‚¬ ë± ê¸°ë°˜ ì „íˆ¬"""
        session = combat_session
        session.user.skill_deck = [
            Skill("ê°•íƒ€", slots=3),      # 30% í™•ë¥ 
            Skill("íšŒë³µ", slots=2),      # 20% í™•ë¥ 
            Skill("í™”ì—¼êµ¬", slots=5),    # 50% í™•ë¥ 
        ]

        await session.start()

        skill_usage = {skill.name: 0 for skill in session.user.skill_deck}

        for _ in range(100):
            if session.state != CombatState.IN_PROGRESS:
                break
            result = await session.process_turn()
            skill_usage[result.used_skill.name] += 1

        # í™•ë¥  ë¶„í¬ ê²€ì¦ (ì˜¤ì°¨ í—ˆìš©)
        total = sum(skill_usage.values())
        assert 0.25 <= skill_usage["í™”ì—¼êµ¬"] / total <= 0.55  # ~50%
```

### E2E í…ŒìŠ¤íŠ¸

```python
class TestUserJourneyE2E:
    """ì‚¬ìš©ì ì—¬ì • E2E í…ŒìŠ¤íŠ¸"""

    @pytest.fixture
    async def bot_client(self):
        """í…ŒìŠ¤íŠ¸ìš© ë´‡ í´ë¼ì´ì–¸íŠ¸"""
        async with TestBotClient() as client:
            yield client

    async def test_new_user_first_dungeon(self, bot_client):
        """ì‹ ê·œ ìœ ì € ì²« ë˜ì „ í´ë¦¬ì–´ ì—¬ì •"""
        client = bot_client

        # 1. íšŒì›ê°€ì…
        response = await client.send_command("/ë“±ë¡")
        assert "ë“±ë¡ ì™„ë£Œ" in response.content

        # 2. ì´ˆê¸° ì¥ë¹„ í™•ì¸
        response = await client.send_command("/ì¸ë²¤í† ë¦¬")
        assert "ì´ˆë³´ìì˜ ê²€" in response.content

        # 3. ë˜ì „ ì„ íƒ
        response = await client.send_command("/ë˜ì „")
        view = response.view
        assert "ìŠí˜€ì§„ ìˆ²" in view.options

        # 4. ë˜ì „ ì…ì¥
        await view.select("ìŠí˜€ì§„ ìˆ²")
        assert "ìŠí˜€ì§„ ìˆ²ì— ì…ì¥í–ˆìŠµë‹ˆë‹¤" in response.content

        # 5. íƒí—˜
        await client.click_button("íƒí—˜")

        # 6. ì „íˆ¬ ë°œìƒ
        response = await client.wait_for_message(timeout=5)
        if "ëª¬ìŠ¤í„° ì¶œí˜„" in response.content:
            await client.click_button("ì „íˆ¬")

            # ì „íˆ¬ ì™„ë£Œ ëŒ€ê¸°
            response = await client.wait_for_message(
                check=lambda m: "ìŠ¹ë¦¬" in m.content or "íŒ¨ë°°" in m.content,
                timeout=30
            )

        # 7. ë³´ìƒ í™•ì¸
        if "ìŠ¹ë¦¬" in response.content:
            assert "ê²½í—˜ì¹˜" in response.content
            assert "ê³¨ë“œ" in response.content
```

### í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ëª…ë ¹ì–´

```bash
# ì „ì²´ í…ŒìŠ¤íŠ¸
pytest

# ìœ ë‹› í…ŒìŠ¤íŠ¸ë§Œ
pytest tests/unit/

# íŠ¹ì • íŒŒì¼
pytest tests/unit/test_damage_calculator.py

# íŠ¹ì • í…ŒìŠ¤íŠ¸
pytest tests/unit/test_damage_calculator.py::TestDamageCalculator::test_critical_hit

# ì»¤ë²„ë¦¬ì§€
pytest --cov=service --cov=models --cov-report=html

# E2E í…ŒìŠ¤íŠ¸ (ë³„ë„ ì‹¤í–‰)
pytest tests/e2e/ -v --timeout=60
```

---

## ê¸°ëŠ¥ ì¶”ê°€ í”„ë¡œì„¸ìŠ¤

### 1. TODO ë¦¬ìŠ¤íŠ¸ ìƒì„±

ìƒˆ ê¸°ëŠ¥ ê°œë°œ ì‹œ ë°˜ë“œì‹œ TODO ë¦¬ìŠ¤íŠ¸ ì‘ì„±:

```markdown
## ê¸°ëŠ¥: ì¸ë²¤í† ë¦¬ ì‹œìŠ¤í…œ

### êµ¬í˜„ í•­ëª©
- [ ] UserInventory ëª¨ë¸ ìƒì„±
- [ ] InventoryRepository êµ¬í˜„
- [ ] InventoryService êµ¬í˜„
  - [ ] add_item()
  - [ ] remove_item()
  - [ ] get_items()
  - [ ] sort_items()
- [ ] InventoryView UI êµ¬í˜„
- [ ] /ì¸ë²¤í† ë¦¬ ì»¤ë§¨ë“œ ì¶”ê°€

### í…ŒìŠ¤íŠ¸
- [ ] ìœ ë‹›: InventoryService í…ŒìŠ¤íŠ¸
- [ ] ìœ ë‹›: ì•„ì´í…œ ì •ë ¬ í…ŒìŠ¤íŠ¸
- [ ] í†µí•©: ì•„ì´í…œ íšë“â†’ì¸ë²¤í† ë¦¬ ì €ì¥ íë¦„
- [ ] E2E: ì¸ë²¤í† ë¦¬ ì¡°íšŒ ì»¤ë§¨ë“œ í…ŒìŠ¤íŠ¸

### ë¬¸ì„œ
- [ ] docs/TODO.md ì—…ë°ì´íŠ¸
- [ ] í•„ìš”ì‹œ ê¸°íš ë¬¸ì„œ ìˆ˜ì •
```

### 2. ê°œë°œ ìˆœì„œ

```
1. ê¸°íš ë¬¸ì„œ í™•ì¸ (docs/)
2. TODO ë¦¬ìŠ¤íŠ¸ ì‘ì„±
3. ë¸Œëœì¹˜ ìƒì„± (feature/{ê¸°ëŠ¥ëª…})
4. ëª¨ë¸/ìŠ¤í‚¤ë§ˆ ì„¤ê³„
5. ì„œë¹„ìŠ¤ ë ˆì´ì–´ êµ¬í˜„
6. ìœ ë‹› í…ŒìŠ¤íŠ¸ ì‘ì„± (TDD ê¶Œì¥)
7. UI/View êµ¬í˜„
8. í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„±
9. E2E í…ŒìŠ¤íŠ¸ ì‘ì„±
10. docs/TODO.md ì—…ë°ì´íŠ¸
11. PR ìƒì„±
```

---

## ë””ë ‰í† ë¦¬ êµ¬ì¡° ê·œì¹™

```
CUHABot/
â”œâ”€â”€ bot.py                 # ì§„ì…ì 
â”œâ”€â”€ config.py              # ê²Œì„ ì„¤ì • ìƒìˆ˜
â”œâ”€â”€ exceptions.py          # ì»¤ìŠ¤í…€ ì˜ˆì™¸ í´ë˜ìŠ¤
â”œâ”€â”€ cogs/                  # Discord ì»¤ë§¨ë“œ (Thin Layer)
â”‚   â””â”€â”€ {feature}_command.py
â”œâ”€â”€ service/               # ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ (í•µì‹¬)
â”‚   â”œâ”€â”€ {feature}_service.py
â”‚   â””â”€â”€ {subsystem}/       # ë³µì¡í•œ ì‹œìŠ¤í…œì€ í•˜ìœ„ ë””ë ‰í† ë¦¬
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ {component}.py
â”‚       â””â”€â”€ ...
â”œâ”€â”€ models/                # DB ëª¨ë¸
â”‚   â”œâ”€â”€ {entity}.py
â”‚   â”œâ”€â”€ repos/             # Repository íŒ¨í„´
â”‚   â”‚   â””â”€â”€ {entity}_repo.py
â”‚   â””â”€â”€ util/              # ëª¨ë¸ ìœ í‹¸ë¦¬í‹°
â”œâ”€â”€ DTO/                   # Discord UI Views
â”‚   â””â”€â”€ {feature}_view.py
â”œâ”€â”€ tests/                 # í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ e2e/
â”‚   â””â”€â”€ fixtures/
â”œâ”€â”€ scripts/               # DB ë§ˆì´ê·¸ë ˆì´ì…˜ ë° ì‹œë“œ ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ docs/                  # ê¸°íš ë¬¸ì„œ
â”œâ”€â”€ resources/             # ì •ì  ë¦¬ì†ŒìŠ¤
â””â”€â”€ utility/               # ìœ í‹¸ë¦¬í‹° ìŠ¤í¬ë¦½íŠ¸
```

---

## ì—ëŸ¬ ì²˜ë¦¬ ê·œì¹™

### ì»¤ìŠ¤í…€ ì˜ˆì™¸ ì •ì˜

```python
# exceptions.py
class CUHABotError(Exception):
    """ê¸°ë³¸ ì˜ˆì™¸ í´ë˜ìŠ¤"""
    pass

class UserNotFoundError(CUHABotError):
    """ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ"""
    def __init__(self, user_id: int):
        self.user_id = user_id
        super().__init__(f"User not found: {user_id}")

class InsufficientResourceError(CUHABotError):
    """ìì› ë¶€ì¡± (ê³¨ë“œ, MP ë“±)"""
    pass

class InvalidStateError(CUHABotError):
    """ì˜ëª»ëœ ìƒíƒœ (ì „íˆ¬ ì¤‘ ìŠ¤í‚¬ ë³€ê²½ ë“±)"""
    pass

class CombatRestrictionError(CUHABotError):
    """ì „íˆ¬ ì œí•œ ìœ„ë°˜"""
    pass
```

### ì—ëŸ¬ ì²˜ë¦¬ íŒ¨í„´

```python
# Service ë ˆì´ì–´
async def use_item(self, user_id: int, item_id: int) -> ItemResult:
    session = self.session_manager.get(user_id)

    if session and session.in_combat:
        raise CombatRestrictionError("ì „íˆ¬ ì¤‘ì—ëŠ” ì•„ì´í…œì„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")

    # ... ë¡œì§

# Cog ë ˆì´ì–´
@app_commands.command()
async def ì•„ì´í…œì‚¬ìš©(self, interaction: Interaction, item_id: int):
    try:
        result = await self.item_service.use_item(
            interaction.user.id, item_id
        )
        await interaction.response.send_message(f"âœ… {result.message}")
    except CombatRestrictionError as e:
        await interaction.response.send_message(f"âš ï¸ {e}", ephemeral=True)
    except UserNotFoundError:
        await interaction.response.send_message("âŒ ë¨¼ì € ë“±ë¡í•´ì£¼ì„¸ìš”", ephemeral=True)
```

---

## íƒ€ì… íŒíŠ¸ í•„ìˆ˜

```python
from typing import Optional, List, Dict, Tuple, Union
from dataclasses import dataclass

@dataclass
class CombatResult:
    damage_dealt: int
    damage_taken: int
    skill_used: str
    effects_applied: List[str]
    is_critical: bool

async def calculate_damage(
    attacker: "Entity",
    defender: "Entity",
    skill: Optional["Skill"] = None,
    *,
    ignore_defense: float = 0.0,
    force_critical: bool = False,
) -> Tuple[int, bool]:
    """
    ë°ë¯¸ì§€ ê³„ì‚°

    Args:
        attacker: ê³µê²©ì ì—”í‹°í‹°
        defender: ë°©ì–´ì ì—”í‹°í‹°
        skill: ì‚¬ìš© ìŠ¤í‚¬ (ì—†ìœ¼ë©´ ê¸°ë³¸ ê³µê²©)
        ignore_defense: ë°©ì–´ë ¥ ë¬´ì‹œ ë¹„ìœ¨ (0.0~0.7)
        force_critical: ê°•ì œ ì¹˜ëª…íƒ€ ì—¬ë¶€

    Returns:
        (ìµœì¢… ë°ë¯¸ì§€, ì¹˜ëª…íƒ€ ì—¬ë¶€)

    Raises:
        InvalidStateError: ê³µê²©ìê°€ í–‰ë™ ë¶ˆê°€ ìƒíƒœì¼ ë•Œ
    """
    ...
```

---

## ë¡œê¹… ê·œì¹™

```python
import logging

logger = logging.getLogger(__name__)

class CombatService:
    async def start_combat(self, user_id: int, monster_id: int):
        logger.info(f"Combat started: user={user_id}, monster={monster_id}")

        try:
            # ... ë¡œì§
            logger.debug(f"Turn processed: damage={damage}, hp_remaining={hp}")
        except Exception as e:
            logger.error(f"Combat error: user={user_id}, error={e}", exc_info=True)
            raise

        logger.info(f"Combat ended: user={user_id}, result={result}")
```

---

## í•µì‹¬ ê²Œì„ ê·œì¹™ (ì½”ë“œì— ë°˜ì˜ í•„ìˆ˜)

âš ï¸ **ì´ ê·œì¹™ë“¤ì€ ë°˜ë“œì‹œ ì½”ë“œë¡œ ê°•ì œí•´ì•¼ í•¨:**

1. **ì „íˆ¬ ì¤‘ ì•„ì´í…œ ì‚¬ìš© ë¶ˆê°€**
   ```python
   if session.in_combat:
       raise CombatRestrictionError("ì „íˆ¬ ì¤‘ ì•„ì´í…œ ì‚¬ìš© ë¶ˆê°€")
   ```

2. **ì „íˆ¬ ì¤‘ ìŠ¤í‚¬ ë³€ê²½ ë¶ˆê°€**
   ```python
   if session.in_combat:
       raise CombatRestrictionError("ì „íˆ¬ ì¤‘ ìŠ¤í‚¬ ë³€ê²½ ë¶ˆê°€")
   ```

3. **ì£¼ê°„ íƒ€ì›Œ: ì•„ì´í…œ ì¼ì ˆ ë¶ˆê°€**
   ```python
   if session.content_type == ContentType.WEEKLY_TOWER:
       raise ContentRestrictionError("íƒ€ì›Œì—ì„œëŠ” ì•„ì´í…œ ì‚¬ìš© ë¶ˆê°€")
   ```

4. **ì£¼ê°„ íƒ€ì›Œ: ì¸µ ì‚¬ì´ì—ì„œë§Œ ìŠ¤í‚¬ ë³€ê²½**
   ```python
   if session.content_type == ContentType.WEEKLY_TOWER:
       if session.in_combat:
           raise ContentRestrictionError("ì¸µ ì‚¬ì´ì—ì„œë§Œ ìŠ¤í‚¬ ë³€ê²½ ê°€ëŠ¥")
   ```

5. **íŒ¨ì‹œë¸Œë„ 10ìŠ¬ë¡¯ ì•ˆì— ì¥ì°©**
   ```python
   total_slots = len(active_skills) + len(passive_skills)
   if total_slots > 10:
       raise DeckError("ìŠ¤í‚¬ ìŠ¬ë¡¯ì€ ìµœëŒ€ 10ê°œì…ë‹ˆë‹¤")
   ```

---

## ì²´í¬ë¦¬ìŠ¤íŠ¸ (PR ì „ í™•ì¸)

- [ ] SRP ì¤€ìˆ˜ í™•ì¸
- [ ] if ì¤‘ì²© 3ë‹¨ê³„ ì´í•˜
- [ ] í•¨ìˆ˜ 30ì¤„ ì´í•˜
- [ ] íƒ€ì… íŒíŠ¸ ì¶”ê°€
- [ ] docstring ì‘ì„±
- [ ] ìœ ë‹› í…ŒìŠ¤íŠ¸ ì‘ì„± ë° í†µê³¼
- [ ] í†µí•© í…ŒìŠ¤íŠ¸ ì‘ì„± ë° í†µê³¼
- [ ] E2E í…ŒìŠ¤íŠ¸ ì‘ì„± ë° í†µê³¼
- [ ] docs/TODO.md ì—…ë°ì´íŠ¸
- [ ] í•µì‹¬ ê²Œì„ ê·œì¹™ ìœ„ë°˜ ì—†ìŒ
- [ ] ë¡œê¹… ì¶”ê°€
- [ ] ì—ëŸ¬ ì²˜ë¦¬ ì¶”ê°€
